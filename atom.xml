<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>镜子的掌纹</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-14T18:24:14.489Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tau Jiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>带有返回值的多线程Python实例</title>
    <link href="http://yoursite.com/2018/07/14/threads/"/>
    <id>http://yoursite.com/2018/07/14/threads/</id>
    <published>2018-07-14T18:02:14.000Z</published>
    <updated>2018-07-14T18:24:14.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算密集型-vs-IO密集型"><a href="#计算密集型-vs-IO密集型" class="headerlink" title="计算密集型 vs. IO密集型"></a>计算密集型 vs. IO密集型</h2><p>我们根据任务对CPU的使用情况，可以把任务类型分为计算密集型和IO密集型，计算密集型任务需要大量占用计算资源，适合使用多进程执行，每个进程可以使用独立的CPU核心进行计算；IO密集型任务需要的计算量不大，但可能存在大量的IO、网络延迟等待，适合使用多线程执行。</p><h2 id="有返回值的多线程实例"><a href="#有返回值的多线程实例" class="headerlink" title="有返回值的多线程实例"></a>有返回值的多线程实例</h2><p>Python初始的多线程对返回值的支持不是很好，我们可以通过类的继承来创建一个带有返回值的多进程类。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="title">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, param1)</span></span><span class="symbol">:</span></span><br><span class="line">        Thread.__init_<span class="number">_</span>(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">self</span>.param1 = param1</span><br><span class="line">        <span class="keyword">self</span>.result = None</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(<span class="keyword">self</span>, param1)</span></span><span class="symbol">:</span></span><br><span class="line">        result = None</span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">self</span>.result = <span class="keyword">self</span>.foo(<span class="keyword">self</span>.param1)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_result</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.result</span><br></pre></td></tr></table></figure><p>然后我们就可以轻松地创建多线程：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    t = MyThread(i)</span><br><span class="line">    t_list.<span class="built_in">append</span>(t)</span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_list:</span><br><span class="line">t.<span class="built_in">join</span>()</span><br><span class="line"><span class="built_in">print</span>(t.get_result())</span><br></pre></td></tr></table></figure><p>启动之后<strong>一定要t.join()</strong>将主程序阻塞，等待子进程运行结束，不然主线程比子线程跑的快，会拿不到结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算密集型-vs-IO密集型&quot;&gt;&lt;a href=&quot;#计算密集型-vs-IO密集型&quot; class=&quot;headerlink&quot; title=&quot;计算密集型 vs. IO密集型&quot;&gt;&lt;/a&gt;计算密集型 vs. IO密集型&lt;/h2&gt;&lt;p&gt;我们根据任务对CPU的使用情况，可以把任
      
    
    </summary>
    
      <category term="Technology" scheme="http://yoursite.com/categories/Technology/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Multiprocessing实用技能总结</title>
    <link href="http://yoursite.com/2018/07/13/multiprocessing/"/>
    <id>http://yoursite.com/2018/07/13/multiprocessing/</id>
    <published>2018-07-13T17:24:15.000Z</published>
    <updated>2018-07-13T18:07:30.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用Python多进程"><a href="#为什么要使用Python多进程" class="headerlink" title="为什么要使用Python多进程"></a>为什么要使用Python多进程</h2><p>多线程并发具有内存共享、通信简单等优势，那么为什么我们还要选择多进程呢？下面我引用廖雪峰的Python教程中的一段说明：</p><blockquote><p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p></blockquote><blockquote><p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p></blockquote><blockquote><p>所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p></blockquote><blockquote><p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p></blockquote><h2 id="多进程的优势"><a href="#多进程的优势" class="headerlink" title="多进程的优势"></a>多进程的优势</h2><p>我们有很多的任务是相互独立运行的，也有很多任务实际上是可以通过拆分之后并行加速的。比如一个很大的list需要挨个遍历处理其中的元素，比如一组数据需要分别访问不同的方法处理得到不同的结果等等。</p><p>如果使用for loop来调用执行，实际上是一种串行的方式，必须要等待上一个任务结束才能执行下一个，中间会有大量的不必要的等待时间。</p><h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>我们使用进程池multiprocessing.Pool()来自动管理进程任务，首先要初始化进程池。</p><p>Pool方法接收一个参数MAX_TASKS，用于<strong>设置该进程池最多允许多少个子进程同时执行</strong>，若进程池中的子进程数大于MAX_TASKS，则剩余的子进程会进入等待，每当有子进程执行完毕，就会有新的子进程启动补充进去：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing import Pool</span><br><span class="line">MAX_TASKS = 5</span><br><span class="line">pool = Pool(MAX_TASKS)</span><br></pre></td></tr></table></figure><p>使用多进程可以加速计算的根本原因在于，可以利用多核CPU来分别执行不同的任务，因此最好先了解自己的CPU有多少个核心：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该语句可以获取自己CPU的核心数</span></span><br><span class="line"><span class="attr">NUM_CPUS</span> = multiprocessing.cpu_count()</span><br></pre></td></tr></table></figure><p><strong>为避免多余的任务切换开销，一般MAX_TASKS不要大于NUM_CPUS。</strong></p><p>然后我们需要定义一个function，该方法会被分配给每个新进程然后执行：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child_task</span><span class="params">(param1, param2)</span></span><span class="symbol">:</span></span><br><span class="line"><span class="comment"># do something</span></span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>然后我们可以在主进程中调用apply_async方法来创建新进程并加入进程池中。</p><p>apply_async方法接受两个参数，第一个是要调用执行的方法，第二个是传递给该方法的参数：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NUM_TASKS = <span class="number">10</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(NUM_TASKS):</span><br><span class="line">r = pool.apply_async(child_task, <span class="built_in">args</span>=(param1, param2))</span><br><span class="line">results.<span class="built_in">append</span>(r)</span><br><span class="line"></span><br><span class="line">p.<span class="built_in">close</span>() # 进程池停止接收新进程</span><br><span class="line">p.<span class="built_in">join</span>()  # 阻塞主进程，等待所有子进程结束</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> results:</span><br><span class="line"><span class="built_in">print</span>(r.<span class="built_in">get</span>())</span><br></pre></td></tr></table></figure><p>需要注意到上面的代码中，r.get()需要放到p.close()和p.join()执行进程池回收之后再使用。这是因为apply_async之后的语句是阻塞的，r.get()会等待上一条语句执行完毕才执行，因此<strong>获取返回值的过程最好放在进程池回收以后</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要使用Python多进程&quot;&gt;&lt;a href=&quot;#为什么要使用Python多进程&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用Python多进程&quot;&gt;&lt;/a&gt;为什么要使用Python多进程&lt;/h2&gt;&lt;p&gt;多线程并发具有内存共享、通信简单等优
      
    
    </summary>
    
      <category term="Technology" scheme="http://yoursite.com/categories/Technology/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="multiprocessing" scheme="http://yoursite.com/tags/multiprocessing/"/>
    
  </entry>
  
  <entry>
    <title>用FPN和ROIalign来进行图像检索</title>
    <link href="http://yoursite.com/2018/06/28/2018-6-28/"/>
    <id>http://yoursite.com/2018/06/28/2018-6-28/</id>
    <published>2018-06-28T15:21:40.000Z</published>
    <updated>2018-07-06T03:32:23.050Z</updated>
    
    <content type="html"><![CDATA[<p>上一版的模型出来以后测试发现一个问题，同一张图，低分辨率和高分辨率，检索结果完全不同。并且最气的是，这两张图相互查不到对方，模型输出的两个向量距离很远，这是不可接受的。</p><p>这个问题其实不难想到，深度模型每一层卷积都会对特征图进行压缩，在模型内部自然地形成一个金字塔形的结构（哪怕有padding操作，其实也只是在维持特征图尺寸，实际的信息依然被压缩，这是不可避免的）。就像一个逐渐抽象的过程中，势必要丢掉一些冗余信息，才能抓取到代表性的特征。</p><p>于是乎，当输入的图片本身分辨率很低，即含有的信息量很少时，这种深层压缩的结果会是毁灭性的。可以想象成从飞机上俯视地面上的一个人，你看到的或许仅仅是一个肉色的小色块了。</p><p>这个问题在目标检测中同样存在，之前流行的主流算法都是直接使用骨干网络的最后一层卷积图作为信息的载体，因此，当目标在图中的比例非常小时，往往很难被算法检测到。针对这个问题，Kaiming He大神提出了一个很厉害的通用结构FPN，仅仅是把它直接结合到Faster RCNN上，就让检测的召回率大大提升。</p><p>一般而言，不同阶段的卷积层输出含有不同层次的空间和语义信息，直接从模型的每一段提出来的卷积图是不能混合使用的。FPN通过top-down和横向连接，以及一个3*3的smooth layer解决了这个问题，使不同阶段的特征图语义统一成为现实。</p><p>对于低分辨率的图片，通过把深层卷积图上采样叠加到浅层卷积图上，可以在保留高层次语义信息的基础上，极大地保留空间信息。</p><blockquote><p>k = floor(4 + sqrt(w * h) / 224)</p></blockquote><p>通过这个公式，可以自动根据输入图片的尺寸来调整获取对应尺度的特征图。</p><p>这里有一个疑惑是，很明显在FPN结构中，P2会是该结构受益最大的层，因为它整合了所有阶段的卷积图信息，包含了最丰富的空间和语义信息。在Paper的消融实验里也证实，只使用P2卷积图就能得到非常好的效果。那么为什么还要使用不同阶段的特征图？或者说，何不直接对所有尺度的图片使用P2特征图？</p><p>我的猜测是，也许对于高分辨率图片，其包含的空间信息过于庞大，即使通过深层模型依然可以有所保留，因而不需要再从浅层卷积图获取，这种特征图叠加融合的手段，主要目的还是在改善低分辨率的性能，是一种补偿手段，在高分辨率图上反而会因信息过多而再次带来语义的不统一，这是一种空间与语义的权衡折中。</p><p>从直觉上，通过在图片上建立FPN，再选择合适的尺度特征，就可以用来进行图像检索。相较于目标检测中有RPN提供ROI，在图像检索中只能以整张图作为输入，与ROI类似的，图片的比例也往往不是标准的1:1，提取得到的特征图也是如此，直接插值放缩是不可行的，会破坏原有的空间结构，因此还需要引入ROI池化来使得特征维度统一。根据Mask RCNN的研究，ROI池化存在各种各样的不足之处，ROIalign是一个更好的策略。</p><p>图像检索不同于目标检测的另一点是，ROI的边界往往是紧贴检测对象的，换言之，目标会充满整个ROI；而图片并非如此，往往还会存在大量的留白区域，因此直接对全图进行ROIalign同样会导致得到的特征的不一致，这里我才用了以下策略来对要输入模型的图片进行预处理：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 伪代码</span></span><br><span class="line"><span class="meta"># 获取长边</span></span><br><span class="line">pad = img.width <span class="keyword">if</span> img.width &gt; img.height <span class="keyword">else</span> img.height</span><br><span class="line"><span class="meta"># 用长边对图片进行扩充</span></span><br><span class="line">Padding(img)</span><br><span class="line"><span class="meta"># 从图片中心截取pad*pad的区域</span></span><br><span class="line">CenterCrop(img, pad)</span><br></pre></td></tr></table></figure><p>如此一来，我们就得到了将短边延拓到长边尺寸的图片。我们在这个图片的基础上进行FPN和ROIalign得到最终的特征向量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一版的模型出来以后测试发现一个问题，同一张图，低分辨率和高分辨率，检索结果完全不同。并且最气的是，这两张图相互查不到对方，模型输出的两个向量距离很远，这是不可接受的。&lt;/p&gt;
&lt;p&gt;这个问题其实不难想到，深度模型每一层卷积都会对特征图进行压缩，在模型内部自然地形成一个金字
      
    
    </summary>
    
      <category term="Technology" scheme="http://yoursite.com/categories/Technology/"/>
    
    
      <category term="FPN" scheme="http://yoursite.com/tags/FPN/"/>
    
      <category term="ROIalign" scheme="http://yoursite.com/tags/ROIalign/"/>
    
      <category term="Image Retrieval" scheme="http://yoursite.com/tags/Image-Retrieval/"/>
    
  </entry>
  
  <entry>
    <title>随笔：人类语言与神经网络类比</title>
    <link href="http://yoursite.com/2018/05/31/2018-5-31/"/>
    <id>http://yoursite.com/2018/05/31/2018-5-31/</id>
    <published>2018-05-31T21:29:06.000Z</published>
    <updated>2018-05-31T19:02:07.233Z</updated>
    
    <content type="html"><![CDATA[<p>在神经网络构筑的维度空间中不断变换的向量，其实很像一种语言，训练神经网络，如同在创造一门新的符号语言。</p><p>我觉得这是一个很有意思的类比，人类的语言和特征向量之间，存在着很多有意思的相似之处。</p><p>当一张图片通过神经网络后，变为了一条某维度里的向量，这个过程就如同人看见这张图片后，可以描述图片内容为：一只很像熊猫的动物懒洋洋地趴在翠绿色的竹林正中间的灰色的石头上。这句描述的话就可以看成一个向量。</p><p>向量的维度是可以变换的，就如同语言描述可以改变，同样的一张图片，或许我们也可以描述为：一只熊猫，或者一只熊猫趴在石头上。</p><p>我们的分类模型其实就是把输出的向量维度数与分类个数联系在了一起，在“人，狗，熊猫”这个三分类的问题下，毫无疑问那张图片会在“熊猫”上得分最高。</p><p>卷积神经网络之所以更加成功，原因就在于它更关注局部特征，如果要类比的话，我觉得它就像一种针对细节进行详细描述的语言修辞，而全连接层更像在归纳总结一些关键词或者概述性的语言：图片通过卷积网络后我们得到了一串非常冗长的、细碎的细节描写，然后通过全连接层变为一系列关键词。</p><p>假如我们在最后的全连接层前面新加入了一层，问题就变得很有意思了，假如还是“人，狗，熊猫”的三分类问题，我们在前面加入了一层100个单元的隐藏层，这个过程就好像是先把卷积层的描述归纳为100个关键词，且这100个词的不同权重组合能够最终归纳为“人，狗，熊猫”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在神经网络构筑的维度空间中不断变换的向量，其实很像一种语言，训练神经网络，如同在创造一门新的符号语言。&lt;/p&gt;
&lt;p&gt;我觉得这是一个很有意思的类比，人类的语言和特征向量之间，存在着很多有意思的相似之处。&lt;/p&gt;
&lt;p&gt;当一张图片通过神经网络后，变为了一条某维度里的向量，这个
      
    
    </summary>
    
      <category term="Notes" scheme="http://yoursite.com/categories/Notes/"/>
    
    
      <category term="卷积层" scheme="http://yoursite.com/tags/%E5%8D%B7%E7%A7%AF%E5%B1%82/"/>
    
      <category term="全连接层" scheme="http://yoursite.com/tags/%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82/"/>
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>随笔：飞机上1</title>
    <link href="http://yoursite.com/2018/05/28/2018-5-28/"/>
    <id>http://yoursite.com/2018/05/28/2018-5-28/</id>
    <published>2018-05-29T01:44:12.000Z</published>
    <updated>2018-05-31T17:41:49.953Z</updated>
    
    <content type="html"><![CDATA[<p>2018.5.28 21:00 成都-&gt;北京</p><p>在生活中你我应该都有过这样的经历：自己的某种想法、某种情感、某种感受，找不到任何词句来形容，不论怎么组织语言，表达出来的东西似乎都离自己内心的那个点差了些什么。</p><p>你我应该也都有过这种体验：某时某刻，突然听到某个人说的一句话，某首歌的一节词，某篇文章的一些句子，突然直戳内心，道尽了你一直以来难以言表的某些东西，使你感到从内到外的深切共鸣。</p><p>夏目漱石曾有一个经典的比喻，他形容日语是高情境的语言，当日本人希望表达“我爱你”时，用“月色真美”将会更加恰当。木心说“文字的简练来源于内心的真诚，我十二万分的爱你，就不如说，我爱你”。</p><p>我们的思想、情感、感受、思维，应该是一种很高维度的东西，而相比之下，我们的语言是低维的。所以才会出现那么多的词不达意、难以言说。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018.5.28 21:00 成都-&amp;gt;北京&lt;/p&gt;
&lt;p&gt;在生活中你我应该都有过这样的经历：自己的某种想法、某种情感、某种感受，找不到任何词句来形容，不论怎么组织语言，表达出来的东西似乎都离自己内心的那个点差了些什么。&lt;/p&gt;
&lt;p&gt;你我应该也都有过这种体验：某时某
      
    
    </summary>
    
      <category term="Notes" scheme="http://yoursite.com/categories/Notes/"/>
    
    
      <category term="思维 语言 夏目漱石 木心 维度" scheme="http://yoursite.com/tags/%E6%80%9D%E7%BB%B4-%E8%AF%AD%E8%A8%80-%E5%A4%8F%E7%9B%AE%E6%BC%B1%E7%9F%B3-%E6%9C%A8%E5%BF%83-%E7%BB%B4%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>无题</title>
    <link href="http://yoursite.com/2018/05/09/%E6%97%A0%E9%A2%98/"/>
    <id>http://yoursite.com/2018/05/09/无题/</id>
    <published>2018-05-09T20:40:56.000Z</published>
    <updated>2018-05-09T08:54:37.845Z</updated>
    
    <content type="html"><![CDATA[<p>看着秋日四五点的太阳</p><p>总想到行将沉没的爱情</p><p>虽然还留有光辉的外表在强装</p><p>但我们都明晰地感觉到那里面已经冷了</p><p>或许必须承认的是其中还有温度吧</p><p>但我们都诚实地添了衣服</p><p>为迎接不远到来的寒夜</p><p>这看上去像是一种要自欺的态度</p><p>现实又冷厉得无可辩驳</p><p>此时沐浴在余晖下面</p><p>街上的行人是最线条分明的</p><p>多情者纵情开怀及时行乐</p><p>痴情者惘然自立冰冷不觉</p><p>无情者故自前行目不斜分</p><p>一时街道上疏影横斜泾渭明</p><p>前望后顾恍如一般景色</p><p>竟像是身立明镜之前</p><p>然陷身其内又不知左右何方是人何处是影</p><p>所以我讷讷然站在那里</p><p>唯恐撞上冰冷坚硬的镜面</p><p>身觉冰冷入袭却举步不得</p><p>落在旁人眼里</p><p>大概一如我所见的街上众人吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看着秋日四五点的太阳&lt;/p&gt;
&lt;p&gt;总想到行将沉没的爱情&lt;/p&gt;
&lt;p&gt;虽然还留有光辉的外表在强装&lt;/p&gt;
&lt;p&gt;但我们都明晰地感觉到那里面已经冷了&lt;/p&gt;
&lt;p&gt;或许必须承认的是其中还有温度吧&lt;/p&gt;
&lt;p&gt;但我们都诚实地添了衣服&lt;/p&gt;
&lt;p&gt;为迎接不远到来的寒夜&lt;/p
      
    
    </summary>
    
      <category term="Emotion" scheme="http://yoursite.com/categories/Emotion/"/>
    
    
      <category term="脉络" scheme="http://yoursite.com/tags/%E8%84%89%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>论文笔记：Faster R-CNN Features for Instance Search</title>
    <link href="http://yoursite.com/2018/05/07/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%9AFaster%20R-CNN%20Features%20for%20Instance%20Search/"/>
    <id>http://yoursite.com/2018/05/07/论文阅读笔记：Faster R-CNN Features for Instance Search/</id>
    <published>2018-05-07T04:36:53.000Z</published>
    <updated>2018-05-09T09:25:55.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVPR-2016-Faster-R-CNN-Features-for-Instance-Search"><a href="#CVPR-2016-Faster-R-CNN-Features-for-Instance-Search" class="headerlink" title="[CVPR 2016] Faster R-CNN Features for Instance Search"></a>[CVPR 2016] Faster R-CNN Features for Instance Search</h1><p>Paper: <a href="https://arxiv.org/abs/1604.08893" target="_blank" rel="noopener">Link</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><ul><li>研究基于CNN的目标检测网络得到的feature是否有利于image retrieval</li><li>研究对目标检测网络进行fine-tune后检索效果是否有所提升</li><li>实验数据集：<ul><li>Oxford Building 5K</li><li>Paris Buildings 6K</li><li>TRECVid Instance Search 2013</li></ul></li></ul><h3 id="What-they-do"><a href="#What-they-do" class="headerlink" title="What they do"></a>What they do</h3><ul><li>通过一次前向传播从CNN中提取出图像的全局和局部特征</li><li>利用从RPN中学到的位置信息设计空间重排方案</li><li>分析了对目标检测CNN进行fine-tune对检索的影响</li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul><li>利用目标检测的CNN特征可以用于图像检索</li><li>使用检索的图像对CNN进行微调，可以较大提升检索效果</li></ul><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><ol><li>利用预训练的CNNs提取现成的特征，在图像检索通用数据集上获得了不错的效果</li><li>实例检索系统 = 快速筛选（对数据库进行重排） + 高级检索（一些高计算量的阶段）。</li><li>常见的重排方式有<strong>几何验证</strong>和<strong>空间分析</strong></li><li>空间分析重排是指，使用不同尺寸的滑动窗口滑过图像，获得图像内部不同局部区域的特征表达，将这些局部特征与查询实例进行比对。</li></ol><h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><h4 id="CNNs-for-Instance-Search"><a href="#CNNs-for-Instance-Search" class="headerlink" title="CNNs for Instance Search"></a>CNNs for Instance Search</h4><ul><li>早期研究中利用全连接层的特征进行图像检索</li><li>将从不同图像sub-patches提取的全连接层特征进行结合，得到更好的结果</li><li>研究发现图像检索领域使用卷积层特征进行，比全连接层特征结果更好</li></ul><h4 id="Object-Detection-CNNs"><a href="#Object-Detection-CNNs" class="headerlink" title="Object Detection CNNs"></a>Object Detection CNNs</h4><ul><li>早期使用滑动窗口方法</li><li>随后R-CNN采用Selective Search</li><li>现在使用端到端的方法</li></ul><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><h3 id="CNN-based-Representations"><a href="#CNN-based-Representations" class="headerlink" title="CNN-based Representations"></a>CNN-based Representations</h3><ul><li>作者将查询实例定义为找到<strong>包含查询目标的边界框</strong></li><li>提出两种池化方案：<ul><li><strong>Image-wise pooling of activations(IPA)</strong>:忽略操作目标建议的所有层，只从最后一个卷积层提取特征，对所有滤波器的输出进行求和</li><li><strong>Region-wise pooling of activations(RPA)</strong>：利用区域池化层提取RPN得到的目标建议的特征。对于每个建议窗口，都可以利用其中RoI池化层的输出来生成表达。</li></ul></li><li>求和池化需要进行L2标准化、白化、L2标准化，而最大池化仅仅进行一次L2标准化</li></ul><h3 id="Fine-tuning-Faster-R-CNN"><a href="#Fine-tuning-Faster-R-CNN" class="headerlink" title="Fine-tuning Faster R-CNN"></a>Fine-tuning Faster R-CNN</h3><ul><li>作者提出了两种微调方案：<ol><li>只更新分类这一分支的全连接层的权重</li><li>前两个卷积层之后的所有层都更新</li></ol></li></ul><h3 id="Image-Retrieval"><a href="#Image-Retrieval" class="headerlink" title="Image Retrieval"></a>Image Retrieval</h3><ul><li>作者提出检索由三步构成：<ol><li>快速筛选</li><li>空间重排</li><li>扩展查询</li></ol></li><li>快速筛选是利用IPA，即图像的全局表达进行一次过滤，只保留前N个结果</li><li>空间重排由两种方法：<ol><li>CA-SR：假设类别不可知，将查询实例经过网络得到的所有RPA，与快速筛选后剩下的每幅图的RPA进行比较</li><li>CS-SR：使用微调后的网络，可以用每个RPN预测的分类得分作为查询对象的相似分数</li></ol></li><li>扩展查询策略为取重排后的前M个结果的特征向量，对他们进行求和平均，用平均后得到的结果重新进行一次查询</li></ul><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><p>图像检索实际上是把图片转为向量在高维空间中位置的比较，两个向量越近，距离越短，则说明越相似。直接使用从整张图片得到的特征向量进行比对的图片检索系统效果有很大的优化空间，因为图片中与检索目标无关的信息越多，就会加大向量在其他维度的权重，进而使得向量在空间中的位置发生偏移，与希望得到的结果的距离变大，这种现象随着查询目标在原图中所占比例的大小越小、显著性越低、对比越不强烈，检索偏差也会越大。</p><p>举一个比较简单而极端的例子：我们可以想象有一个10维的空间，在这个空间中，只有第1，2，3维的方向上代表了我们所查询的对象的表达（实际上可能每个维度上都有不同的权重，在这里我们极端地假设其他维度上权重为0）。通过CNN得到的特征向量，实际上是由图片内的内容共同组成的，与我们所查询的对象无关的内容也掺杂其中，这些无关内容在10维空间中标示为其他维度上的不同权重。</p><p>因此，图片全局的表达可以用作第一步的快速筛选，然后再使用局部表达精确检索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CVPR-2016-Faster-R-CNN-Features-for-Instance-Search&quot;&gt;&lt;a href=&quot;#CVPR-2016-Faster-R-CNN-Features-for-Instance-Search&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="Technology" scheme="http://yoursite.com/categories/Technology/"/>
    
    
      <category term="Image Retrieval" scheme="http://yoursite.com/tags/Image-Retrieval/"/>
    
      <category term="CV" scheme="http://yoursite.com/tags/CV/"/>
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
</feed>
